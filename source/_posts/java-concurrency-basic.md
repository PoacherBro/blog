并发编程是Java语言的重要特点之一，在Java平台上提供了许多基本的并发功能来辅助开发多线程应用程序。然而，这些相对底层的并发功能与上层应用程序的并发语义之间并不存在一种简单而直观的映射关系。因此，如何在Java并发应用程序中正确且搞笑的使用这些功能就成了Java开发人员的关注重点。

很多时候我们发现并没有接触什么实际的多线程开发场景，大部分都是写一些业务代码而已。这是因为现在很多框架已经封装了多线程的实现与调度，从而让开发人员关注在业务逻辑，简化开发成本。  

譬如我们Web开发用到的Servlet，在web容器的设计中，每一个servlet的调用，都是开启了一个线程去处理（在没有达到线程池最大限度下），并且管理它的生命周期。然而这些对于开发人员都是透明的。  

所以我们需要了解Java多线程的实现原理，知道Web容器是如何管理线程以达到高性能的优化。

这里我们首先来了解Java多线程相关的一些基本概念。

## 1. 进程与线程

### 进程
　　说起进程的由来，我们需要从操作系统的发展历史谈起。

　　也许在今天，我们无法想象在很多年以前计算机是什么样子。我们现在可以用计算机来做很多事情：办公、娱乐、上网，但是在计算机刚出现的时候，是为了解决数学计算的问题，因为很多大量的计算通过人力去完成是很耗时间和人力成本的。在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作。当用户在思考或者输入数据时，计算机就在等待。显然这样效率和很低下，因为很多时候，计算机处于等待用户输入的状态。

　　那么能不能把一系列需要操作的指令预先写下来，形成一个清单，然后一次性交给计算机，计算机不断地去读取指令来进行相应的操作？就这样，批处理操作系统诞生了。用户可以将需要执行的多个程序写在磁带上，然后交由计算机去读取并逐个地执行这些程序，并将输出结果写到另一个磁带上。

　　虽然批处理操作系统的诞生极大地提高了任务处理的便捷性，但是仍然存在一个很大的问题：

　　假如有两个任务A和B，任务A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。人们于是想，能否在任务A读取数据的过程中，让任务B去执行，当任务A读取完数据之后，让任务B暂停，然后让任务A继续执行？

　　但是这样就有一个问题，原来每次都是一个程序在计算机里面运行，也就说内存中始终只有一个程序的运行数据。而如果想要任务A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？多个程序使用的数据如何进行辨别呢？并且当一个程序运行暂停后，后面如何恢复到它之前执行的状态呢？

　　这个时候人们就发明了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂时时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。

　　这就是并发，能够让操作系统从宏观上看起来同一个时间段有多个任务在执行。换句话说，进程让操作系统的并发成为了可能。

　　注意，虽然并发从宏观上看有多个任务在执行，但是事实上，任一个具体的时刻，只有一个任务在占用CPU资源（当然是对于单核CPU来说的）。

### 线程

　　在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。因为一个进程在一个时间段内只能做一件事情，如果一个进程有多个子任务，只能逐个地去执行这些子任务。比如对于一个监控系统来说，它不仅要把图像数据显示在画面上，还要与服务端进行通信获取图像数据，还要处理人们的交互操作。如果某一个时刻该系统正在与服务器通信获取图像数据，而用户又在监控系统上点击了某个按钮，那么该系统就要等待获取完图像数据之后才能处理用户的操作，如果获取图像数据需要耗费10s，那么用户就只有一直在等待。显然，对于这样的系统，人们是无法满足的。

　　那么可不可以将这些子任务分开执行呢？即在系统获取图像数据的同时，如果用户点击了某个按钮，则会暂停获取图像数据，而先去响应用户的操作（因为用户的操作往往执行时间很短），在处理完用户操作之后，再继续获取图像数据。人们就发明了线程，让一个线程去执行一个子任务，这样一个进程就包括了多个线程，每个线程负责一个独立的子任务，这样在用户点击按钮的时候，就可以暂停获取图像数据的线程，让UI线程响应用户的操作，响应完之后再切换回来，让获取图像的线程得到CPU资源。从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。

　　换句话说，进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。

　　但是要注意，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。

### 并发

　　由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在一个问题：

　　如果多个线程要同时访问某个资源，怎么处理？

　　这个问题就是后序文章中要重点讲述的同步问题。

　　那么可能有朋友会问，现在很多时候都采用多线程编程，那么是不是多线程的性能一定就由于单线程呢？

　　不一定，要看具体的任务以及计算机的配置。比如说：

　　对于单核CPU，如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。

　　但是对于比如交互类型的任务，肯定是需要使用多线程的。

　　而对于多核CPU，对于解压文件来说，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。

　　虽然多线程能够提升程序性能，但是相对于单线程来说，它的编程要复杂地多，要考虑线程安全问题。因此，在实际编程过程中，要根据实际情况具体选择。

## 2. JVM内存模型（JMM）

首先我们用网上一个图来更清晰的展示Java虚拟机内存模型。
![]()



Java的锁
1, 利用synchronize关键字，可以使用类的内置锁。可以加在方法和一个object变量上。
如：
synchronize(obj)
synchronize(this)
public int synchronize add() {}

2. 锁 Lock
Lock其实实现了synchronize关键字的功能，你可以会很奇怪为什么JDK设计人员会重新用Java语义设计一个锁的功能，这不是自己打自己的脸么？

